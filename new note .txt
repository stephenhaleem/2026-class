# Comprehensive Supabase Authentication Teaching Notes

## Table of Contents
1. [Overview](#overview)
2. [Backend Setup (SQL)](#backend-setup-sql)
3. [Frontend Authentication (JavaScript)](#frontend-authentication-javascript)
4. [How It All Works Together](#how-it-all-works-together)
5. [Common Issues & Troubleshooting](#common-issues--troubleshooting)

---

## Overview

This application uses **Supabase** as a Backend-as-a-Service (BaaS) that provides:
- **Authentication** - User signup, login, OAuth (Google)
- **Database** - PostgreSQL database with Row Level Security (RLS)
- **Storage** - File uploads for images

**Key Concept**: Supabase handles the complex backend work, so you can focus on building your frontend.

---

## Backend Setup (SQL)

### 1. Database Tables

#### **profiles Table**
```sql
create table profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  username text unique,
  created_at timestamp default now()
);
```

**What this does:**
- Creates a `profiles` table to store additional user information
- `id uuid primary key` - Unique identifier for each profile
- `references auth.users(id)` - Links to Supabase's built-in auth system
- `on delete cascade` - If a user deletes their account, their profile is automatically deleted too
- `username text unique` - Ensures no two users can have the same username
- `created_at timestamp default now()` - Automatically records when the profile was created

**Why we need this:**
Supabase's `auth.users` table stores email/password info, but you often need additional user data (username, bio, avatar, etc.). The `profiles` table is where you store that.

---

#### **posts Table**
```sql
create table posts (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references auth.users(id) on delete cascade,
  title text,
  content text,
  image_url text,
  created_at timestamp default now()
);
```

**What this does:**
- Creates a `posts` table for user-generated content
- `id uuid default gen_random_uuid()` - Automatically generates a unique ID for each post
- `user_id uuid references auth.users(id)` - Links each post to the user who created it
- `on delete cascade` - If a user is deleted, all their posts are deleted too
- `title`, `content`, `image_url` - Store the post data
- `created_at` - Records when the post was created

---

### 2. Row Level Security (RLS) Policies

**What is RLS?**
Row Level Security is like a bouncer at a club - it decides who can see and modify which rows in your database. Without RLS, anyone could access all data.

#### **Profile Policies**

```sql
create policy "Public profiles read"
on profiles for select
using (true);
```
- **What it does:** Anyone can READ all profiles
- `for select` - Applies to SELECT queries (reading data)
- `using (true)` - Always allows access (no conditions)

```sql
create policy "User insert own profile"
on profiles for insert
with check (auth.uid() = id);
```
- **What it does:** Users can only INSERT their own profile
- `for insert` - Applies when creating new rows
- `auth.uid() = id` - The user's ID must match the profile's ID
- This prevents users from creating profiles for other people

```sql
create policy "User update own profile"
on profiles for update
using (auth.uid() = id);
```
- **What it does:** Users can only UPDATE their own profile
- Prevents users from editing other people's profiles

---

#### **Post Policies**

```sql
create policy "Public read posts"
on posts for select
using (true);
```
- Anyone can view all posts (public feed)

```sql
create policy "User insert post"
on posts for insert
with check (auth.uid() = user_id);
```
- Users can only create posts with their own `user_id`
- Prevents impersonation

```sql
create policy "User update post"
on posts for update
using (auth.uid() = user_id);
```
- Users can only edit their own posts

```sql
create policy "User delete post"
on posts for delete
using (auth.uid() = user_id);
```
- Users can only delete their own posts

**Key Concept**: `auth.uid()` is a Supabase function that returns the currently logged-in user's ID. If no one is logged in, it returns `null`.

---

### 3. Database Trigger (Auto-create Profile)

```sql
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id)
  values (new.id);
  return new;
end;
$$ language plpgsql security definer;
```

**What is this?**
This is a PostgreSQL function that automatically creates a profile when a new user signs up.

**Breaking it down:**
- `create function` - Defines a reusable function
- `returns trigger` - This function is triggered by an event
- `$$` - Marks the beginning and end of the function body
- `begin ... end` - The function's logic
- `insert into public.profiles (id) values (new.id)` - Creates a new profile row with the user's ID
- `new.id` - In triggers, `new` refers to the newly inserted row (the new user)
- `language plpgsql` - PostgreSQL's procedural language
- `security definer` - Runs with the privileges of the function creator (bypasses RLS)

```sql
create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();
```

**What this does:**
- Creates a trigger named `on_auth_user_created`
- `after insert on auth.users` - Fires AFTER a new user is added to `auth.users`
- `for each row` - Runs once for each new user
- `execute procedure public.handle_new_user()` - Calls our function

**Why this matters:**
Without this trigger, users would sign up but wouldn't have a profile. You'd need to manually create profiles, which is error-prone. This ensures every user automatically gets a profile.

---

## Frontend Authentication (JavaScript)

### 1. Initializing Supabase

```javascript
const supabaseUrl = "https://jaeayaedtvzueucsctvo.supabase.co";
const supabaseKey = "eyJhbGc...";
const client = supabase.createClient(supabaseUrl, supabaseKey);
```

**What this does:**
- `supabaseUrl` - Your project's unique URL
- `supabaseKey` - The "anon" (anonymous) public key - safe to expose in frontend code
- `createClient()` - Creates a connection to your Supabase project

**Important:** The anon key is PUBLIC and should be exposed. Supabase's RLS policies protect your data, not the key itself.

---

### 2. Sign Up Function

```javascript
async function signUp() {
  const email = document.getElementById("signup-email").value;
  const password = document.getElementById("signup-password").value;

  const { error } = await client.auth.signUp({ email, password });
  if (error) alert(error.message);
  else alert("Check your email to confirm");
}
```

**Step-by-step:**
1. Gets email and password from HTML input fields
2. `await client.auth.signUp({ email, password })` - Calls Supabase's signup method
3. `async/await` - Waits for Supabase to respond before continuing
4. Returns an object with `error` property (null if successful)
5. If error exists, show it; otherwise, tell user to check email

**What happens on Supabase's end:**
1. Hashes the password (never stores plain text)
2. Creates a new user in `auth.users` table
3. Triggers `on_auth_user_created` → creates profile
4. Sends confirmation email

---

### 3. Login Function

```javascript
async function login() {
  const email = document.getElementById("login-email").value;
  const password = document.getElementById("login-password").value;

  const { error } = await client.auth.signInWithPassword({ email, password });
  if (error) alert(error.message);
  else window.location.href = "dashboard.html";
}
```

**Step-by-step:**
1. Gets email and password from inputs
2. `signInWithPassword()` - Authenticates the user
3. If successful, Supabase creates a session (stores auth token in browser)
4. Redirects to dashboard

**Sessions explained:**
- When you log in, Supabase stores a JWT (JSON Web Token) in your browser
- This token is automatically sent with every request
- It expires after a set time (default: 1 hour, refresh token: 30 days)
- Supabase automatically refreshes tokens in the background

---

### 4. Google OAuth

```javascript
async function signInWithGoogle() {
  const { error } = await client.auth.signInWithOAuth({
    provider: 'google',
    options: {
      redirectTo: window.location.origin + '/dashboard.html'
    }
  });
  
  if (error) alert(error.message);
}
```

**What this does:**
1. Opens Google's login page
2. User logs in with their Google account
3. Google redirects back to your app
4. Supabase creates/logs in the user automatically
5. `redirectTo` - Where to send the user after successful login

**Setup required:**
- Enable Google provider in Supabase Dashboard → Authentication → Providers
- Add authorized redirect URLs in Google Cloud Console

---

### 5. Logout Function

```javascript
async function logout() {
  await client.auth.signOut();
  window.location.href = "index.html";
}
```

**What this does:**
1. `signOut()` - Destroys the session (removes auth token)
2. Redirects to homepage
3. User is now logged out; `auth.uid()` returns null

---

### 6. Creating Posts

```javascript
async function createPost() {
  const titleInput = document.getElementById("title");
  const contentInput = document.getElementById("content");
  const imageInput = document.getElementById("image");

  if (!titleInput.value || !contentInput.value) return;

  const title = titleInput.value;
  const content = contentInput.value;
  const file = imageInput.files[0];

  const { data: { user } } = await client.auth.getUser();
  if (!user) return alert("Not logged in");

  let imageUrl = null;

  if (file) {
    const fileName = `${Date.now()}-${file.name}`;
    await client.storage
      .from("post-images")
      .upload(fileName, file);

    imageUrl = client.storage
      .from("post-images")
      .getPublicUrl(fileName).data.publicUrl;
  }

  await client.from("posts").insert({
    title,
    content,
    image_url: imageUrl,
    user_id: user.id
  });

  titleInput.value = "";
  contentInput.value = "";
  imageInput.value = "";

  loadMyPosts();
}
```

**Breaking it down:**

1. **Get form values:**
   ```javascript
   const title = titleInput.value;
   const content = contentInput.value;
   const file = imageInput.files[0];
   ```

2. **Validate inputs:**
   ```javascript
   if (!titleInput.value || !contentInput.value) return;
   ```
   - Stops execution if title or content is empty

3. **Check authentication:**
   ```javascript
   const { data: { user } } = await client.auth.getUser();
   if (!user) return alert("Not logged in");
   ```
   - `getUser()` - Gets currently logged-in user from session
   - Destructuring: `{ data: { user } }` extracts `user` from nested object
   - If not logged in, user is null

4. **Upload image (if provided):**
   ```javascript
   if (file) {
     const fileName = `${Date.now()}-${file.name}`;
     await client.storage
       .from("post-images")
       .upload(fileName, file);

     imageUrl = client.storage
       .from("post-images")
       .getPublicUrl(fileName).data.publicUrl;
   }
   ```
   - `Date.now()` - Generates unique timestamp to prevent filename conflicts
   - `.from("post-images")` - Specifies the storage bucket
   - `.upload(fileName, file)` - Uploads the file
   - `.getPublicUrl()` - Gets the URL to access the uploaded image

5. **Insert post into database:**
   ```javascript
   await client.from("posts").insert({
     title,
     content,
     image_url: imageUrl,
     user_id: user.id
   });
   ```
   - `.from("posts")` - Specifies the table
   - `.insert()` - Adds a new row
   - RLS policy checks: Is `auth.uid()` equal to `user.id`? (Yes, because we're logged in)

6. **Clear form & reload posts:**
   ```javascript
   titleInput.value = "";
   contentInput.value = "";
   imageInput.value = "";
   loadMyPosts();
   ```

---

### 7. Loading Posts

```javascript
async function loadPosts() {
  const container = document.getElementById("posts");
  if (!container) return;

  const { data } = await client
    .from("posts")
    .select("*")
    .order("created_at", { ascending: false });

  container.innerHTML = "";

  data.forEach(post => {
    container.innerHTML += `
      <div class="post">
        <h3>${post.title}</h3>
        <p>${post.content}</p>
        ${post.image_url ? `<img src="${post.image_url}">` : ""}
      </div>
    `;
  });
}
```

**Breaking it down:**

1. **Check if container exists:**
   ```javascript
   if (!container) return;
   ```
   - Prevents errors if on a page without a "posts" element

2. **Query database:**
   ```javascript
   const { data } = await client
     .from("posts")
     .select("*")
     .order("created_at", { ascending: false });
   ```
   - `.select("*")` - Get all columns
   - `.order("created_at", { ascending: false })` - Newest posts first
   - Returns: `{ data: [...], error: null }` or `{ data: null, error: {...} }`

3. **Clear existing content:**
   ```javascript
   container.innerHTML = "";
   ```

4. **Generate HTML for each post:**
   ```javascript
   data.forEach(post => {
     container.innerHTML += `
       <div class="post">
         <h3>${post.title}</h3>
         <p>${post.content}</p>
         ${post.image_url ? `<img src="${post.image_url}">` : ""}
       </div>
     `;
   });
   ```
   - Template literals (backticks) allow multi-line strings and interpolation
   - `${post.title}` - Inserts the post's title
   - Ternary operator: `condition ? ifTrue : ifFalse`
   - Shows image only if `image_url` exists

---

### 8. Loading User's Own Posts

```javascript
async function loadMyPosts() {
  const container = document.getElementById("my-posts");
  if (!container) return;

  const { data: { user } } = await client.auth.getUser();
  if (!user) return;

  const { data } = await client
    .from("posts")
    .select("*")
    .eq("user_id", user.id)
    .order("created_at", { ascending: false });

  container.innerHTML = "";

  data.forEach(post => {
    container.innerHTML += `
      <div class="post">
        <h3>${post.title}</h3>
        <p>${post.content}</p>
        ${post.image_url ? `<img src="${post.image_url}" />` : ""}
        <button onclick="deletePost('${post.id}', '${post.image_url || ""}')">
          Delete
        </button>
      </div>
    `;
  });
}
```

**Key difference from `loadPosts()`:**

```javascript
.eq("user_id", user.id)
```
- `.eq()` - "Equals" filter
- Only returns posts where `user_id` matches the logged-in user's ID
- RLS policy automatically enforces this, but filtering makes the query faster

**Delete button:**
```javascript
<button onclick="deletePost('${post.id}', '${post.image_url || ""}')">
  Delete
</button>
```
- Inline event handler (not best practice, but simple for beginners)
- Passes post ID and image URL to delete function
- `post.image_url || ""` - If no image, pass empty string

---

### 9. Deleting Posts

```javascript
async function deletePost(id) {
  await client.from("posts").delete().eq("id", id);
  loadMyPosts();
}
```

**What this does:**
1. `.delete()` - Deletes rows from the table
2. `.eq("id", id)` - Only delete the post with matching ID
3. RLS policy ensures you can only delete your own posts
4. `loadMyPosts()` - Refreshes the UI

**Note:** This code doesn't delete the image from storage. In production, you'd want to:
```javascript
async function deletePost(id, imageUrl) {
  // Delete image from storage if exists
  if (imageUrl) {
    const fileName = imageUrl.split('/').pop();
    await client.storage.from("post-images").remove([fileName]);
  }
  
  // Delete post from database
  await client.from("posts").delete().eq("id", id);
  loadMyPosts();
}
```

---

## How It All Works Together

### **The Authentication Flow:**

1. **User visits site** → Not logged in → `auth.uid()` = null
2. **User signs up** → Email & password sent to Supabase
3. **Supabase creates user** → Trigger creates profile → Sends confirmation email
4. **User confirms email** → Account activated
5. **User logs in** → Supabase creates session → JWT token stored in browser
6. **User creates post** → JavaScript sends post data with user ID
7. **RLS policies check** → Is `auth.uid() == post.user_id`? Yes → Allow insert
8. **Post saved** → User sees their post on dashboard
9. **User logs out** → Session destroyed → `auth.uid()` = null

### **Security in Action:**

**Scenario 1: Hacker tries to create a post as another user**
```javascript
// Hacker tries to insert with someone else's user_id
await client.from("posts").insert({
  title: "Hacked!",
  user_id: "someone-else-id"
});
```
**Result:** RLS policy blocks it because `auth.uid()` (hacker's ID) ≠ `"someone-else-id"`

**Scenario 2: Hacker tries to read auth.users table**
```javascript
await client.from("auth.users").select("*");
```
**Result:** Supabase blocks access - `auth.users` is protected, not exposed to frontend

**Scenario 3: User tries to delete another user's post**
```javascript
await client.from("posts").delete().eq("id", "other-user-post-id");
```
**Result:** RLS policy blocks it because `auth.uid()` ≠ that post's `user_id`

---

## Common Issues & Troubleshooting

### Issue 1: "New row violates RLS policy"
**Cause:** Trying to insert/update data that violates a policy
**Solution:** 
- Check that `user_id` matches `auth.uid()`
- Ensure user is logged in before performing action
- Verify policies are enabled on the table

### Issue 2: "Cannot read property 'id' of null"
**Cause:** User is not logged in, but code tries to access `user.id`
**Solution:**
```javascript
const { data: { user } } = await client.auth.getUser();
if (!user) {
  alert("Please log in");
  return;
}
```

### Issue 3: Empty results from database query
**Cause:** RLS policies are too restrictive, or user isn't authenticated
**Solution:**
- Check RLS policies are enabled: `ALTER TABLE posts ENABLE ROW LEVEL SECURITY;`
- Verify user is logged in
- Test query in Supabase SQL editor (has admin access)

### Issue 4: Image upload fails
**Cause:** Storage bucket not created or policies not set
**Solution:**
- Create bucket: Supabase Dashboard → Storage → New Bucket → `post-images`
- Set bucket to public: Bucket settings → Public bucket: ON
- Or add storage policy:
```sql
create policy "Public upload"
on storage.objects for insert
with check (bucket_id = 'post-images');
```

### Issue 5: Redirect after OAuth not working
**Cause:** Redirect URL not authorized
**Solution:**
- Supabase Dashboard → Authentication → URL Configuration
- Add your redirect URL to "Redirect URLs" list
- Format: `http://localhost:3000/dashboard.html` or your production URL

---

## Quick Reference

### Essential Supabase Commands

```javascript
// Auth
await client.auth.signUp({ email, password })
await client.auth.signInWithPassword({ email, password })
await client.auth.signInWithOAuth({ provider: 'google' })
await client.auth.signOut()
const { data: { user } } = await client.auth.getUser()

// Database - Select
await client.from("table").select("*")
await client.from("table").select("*").eq("column", value)
await client.from("table").select("*").order("created_at", { ascending: false })

// Database - Insert
await client.from("table").insert({ column: value })

// Database - Update
await client.from("table").update({ column: newValue }).eq("id", id)

// Database - Delete
await client.from("table").delete().eq("id", id)

// Storage
await client.storage.from("bucket").upload(fileName, file)
const { data } = client.storage.from("bucket").getPublicUrl(fileName)
await client.storage.from("bucket").remove([fileName])
```

### Essential SQL Commands

```sql
-- Create table
CREATE TABLE table_name (
  id uuid PRIMARY KEY,
  column_name data_type
);

-- Enable RLS
ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;

-- Create policy
CREATE POLICY "policy_name"
ON table_name
FOR operation
USING (condition);

-- Create trigger
CREATE TRIGGER trigger_name
AFTER INSERT ON table_name
FOR EACH ROW
EXECUTE PROCEDURE function_name();
```

---

## Teaching Tips

1. **Start with the big picture:** Show how auth, database, and storage work together
2. **Use visual diagrams:** Draw the flow from signup → login → create post
3. **Live coding:** Build a simple feature step-by-step with students
4. **Common mistakes:** Show examples of broken RLS policies and how to fix them
5. **Security emphasis:** Explain WHY RLS matters (real-world hacking scenarios)
6. **Debugging practice:** Break something intentionally and fix it together

---

## Next Steps for Students

1. **Add profile editing:** Let users update their username
2. **Add comments:** Create a `comments` table with RLS policies
3. **Add likes:** Track which users liked which posts
4. **Implement pagination:** Load posts 10 at a time
5. **Add search:** Filter posts by title/content
6. **Real-time updates:** Use Supabase's `.on()` subscriptions for live updates

---

**Remember:** Supabase handles the hard backend stuff (servers, databases, security) so you can focus on building great features!